<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unix | Steven Yang's Blog | 杨晨昀]]></title>
  <link href="http://blog.yangchenyun.com/blog/categories/unix/atom.xml" rel="self"/>
  <link href="http://blog.yangchenyun.com/"/>
  <updated>2012-10-08T00:13:59+08:00</updated>
  <id>http://blog.yangchenyun.com/</id>
  <author>
    <name><![CDATA[Steven Yang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understand Unix Pipeline]]></title>
    <link href="http://blog.yangchenyun.com/2012/10/understand-unix-pipeline/"/>
    <updated>2012-10-01T16:54:00+08:00</updated>
    <id>http://blog.yangchenyun.com/2012/10/understand-unix-pipeline</id>
    <content type="html"><![CDATA[<p>For linux beginners, these commands are powerful but confusing:</p>

<pre><code>tail /var/log/nginx.log &gt; /tmp/recent.log
node server.js 2&gt;&amp;1 &gt;/var/log/info.log
ls -al | grep '/.rb' | wc -l
tee &gt;(wc -l &gt;&amp;2) &lt; bigfile | gzip &gt; bigfile.gz
</code></pre>

<p>The shared syntaxes such as <code>&lt;</code>, <code>&gt;</code>, <code>&gt;&amp;1</code> or <code>|</code> indicates one of unix’s best features - standard IO streams. Standard IO streams has been introduced since <a href="http://www.youtube.com/watch?v=tc4ROCJYbm0">the early days of unix</a> and has formed a core part in <a href="http://www.faqs.org/docs/artu/ch01s06.html">unix philosophy</a>.</p>

<blockquote>
  <p>… Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.</p>
</blockquote>

<p>The following sections will explain IO streams of unix and their usage with programs. It will answer the following questions:
- what is standard streams and how does it work with programs?
- how to utilize standard streams in programs?
- what is pipeline and how to use it?
- how to make standard streams work with program arguments?</p>

<p>If your are confused about unix streams, hope the following sections will help you understand the above commands; if you are already familiar with it, [references at the end][#references] might help you unleash more power of it.</p>

<ul id="markdown-toc">
  <li><a href="#the-abstract-io-interface-for-program">The Abstract IO Interface for Program</a>    <ul>
      <li><a href="#example-of-program-talks-with-standard-streams">Example of Program Talks with Standard Streams</a></li>
    </ul>
  </li>
  <li><a href="#io-redirections">IO Redirections</a></li>
  <li><a href="#piping">Piping</a></li>
  <li><a href="#pipe-standard-input--output-as-arguments">Pipe Standard Input / Output as arguments</a>    <ul>
      <li><a href="#process-substitution">Process substitution</a></li>
      <li><a href="#xargs"><code>xargs</code></a></li>
    </ul>
  </li>
  <li><a href="#reference">Reference</a></li>
</ul>

<h2 id="the-abstract-io-interface-for-program">The Abstract IO Interface for Program</h2>
<p>Computer programs need to talk with its environment. It needs to communicate with various hardware such as disk drive, disc, screen, keyboard, mouse, speaker, printer etc. </p>

<p>In operating system predates Unix, program has to contain the ‘knowledge’ for specific devices. It need to know the right ways to talk to various devices. To build a program working with three types of different printers, it needs to contain the pieces to translate program instructions to each printer.</p>

<p><img src="" alt="img of program talks to various devices" /></p>

<p>This binding with devices makes program less portable.</p>

<p>To solve this issue, unix invented the <strong>standard IO streams</strong></p>

<p>Standard IO streams abstract the complexity of reading and writing to different devices with <strong>data stream</strong>. Data stream is merely an ordered sequence of data bytes. Any program could read data stream until the end of a file and it could write data stream without declare the size. This generic ways to read and write data enables program to read input from keyboard devices, files and write data to displays, files, printers etc. without knowing anything about these devices.</p>

<p><img src="" alt="img of program talks to standard io" /></p>

<p>There are three kinds of standard IO streams including standard input, standard output and standard error. Standard input is the data going into a program. By default it is expected from keyboard. Standard output is the where program writes its data to and by default it is the terminal. Standard error is another output stream similar to standard output. It is typically used to output error messages or diagnostics.</p>

<p>Standard streams follows the unix’s phisolophy that <a href="http://en.wikipedia.org/wiki/Everything_is_a_file">‘everything is a file’</a>. So from the program’s point of view, these three standard streams have no difference from normal files. As long as a program could read a file, it could read from standard input; as long as it could write a file, it could write the standard output.</p>

<p>The actual actions of ‘writing to standard output’ is determined by unix itself. It could mean printing to terminal, recording a video tape, burning a disc, sending to printer etc. All of these are handled by the kernel of unix. This feature amplifies the composibility and portablity of a program</p>

<p><img src="" alt="img of program talks to standard io" /></p>

<p>In conslusion, standard IO streams provide an unified input and output interfaces for the programs to communicate with various hardware devices without growing complexities. </p>

<h3 id="example-of-program-talks-with-standard-streams">Example of Program Talks with Standard Streams</h3>
<p>With the knowledge about the standard streams, let’s take a look at one program example.</p>

<p>Type <code>cat</code> in the terminal and now the program will read the default standard input - keyboard. Type <code>first line</code> and <code>&lt;Enter&gt;</code>, it prints to string to the default standard output - the terminal.</p>

<pre><code>$ cat
first line
&gt;first line
</code></pre>

<p><img src="" alt="img of command cat" /></p>

<h2 id="io-redirections">IO Redirections</h2>
<p>Sometimes we want to read data other than the keyboard or write data other than standard output. To alter the default stream source or destination is called <strong>IO Redirection</strong>. This could be archieved through <code>&lt;</code> or <code>&gt;</code>. Let’s first try <code>&gt;</code>:</p>

<pre><code>$ ls -al &gt; /tmp/list.txt
</code></pre>

<p>It redirects the standard output to the file <code>/tmp/list.txt</code> instead of print to terminal.</p>

<p><code>&gt;</code> has a sibling <code>&gt;&gt;</code> which will <strong>append</strong> data to file instead of writing it.</p>

<pre><code>$ ls -al &gt;&gt; /tmp/list.txt
</code></pre>

<p>It appends the result to <code>/tmp/list.text</code> which should contain the same results twice. Let’s read this file now:</p>

<pre><code>$ less &lt; /tmp/list.txt
</code></pre>

<p>It reads standard input from <code>/tmp/list.txt</code> instead of the keyboard.</p>

<p><img src="" alt="img of IO Redirection" /></p>

<p>How about redirect standard error? Use <code>2&gt;</code>:</p>

<pre><code>$ find this-is-not-exist 2&gt; /tmp/error.txt
</code></pre>

<p>The error message is not displayed on the terminal but stored in the <code>/tmp/error.txt</code> file.</p>

<p>The meaning of the <code>2</code> used in the above command is <strong>file descriptor</strong>, they are similar to file name which is used to access files in one system process.</p>

<p>As standard streams don’t have file name, file descriptor is the usual way to access them. The file descriptors for standard input, standard output, standard error are 0, 1, and 2, respectively.</p>

<p>So the above command means: execute the <code>find this-is-not-exist</code> command and redirect the file indicated by the file descriptor 2 (which is standard standard error) to <code>/tmp/error.txt</code>.</p>

<p>File descriptor could also be used as redirection destination:</p>

<pre><code>ls -al 2&gt;&amp;1 &gt;/tmp/result.txt
</code></pre>

<p>This means: execute <code>ls -al</code> and redirects file descriptor 2(standard error) to any destination file descriptor 1(standard output) points to and redirects standard output to file <code>/tmp/result.txt</code>. The <code>&amp;</code> used here is to distinguish between file name <code>1</code> and file descriptor <code>1</code>.</p>

<p><img src="" alt="img of file descriptor cat" /></p>

<h2 id="piping">Piping</h2>
<p>Sometimes a program might write standard output data which might be read by another program as standard input. With the above knowledge it could be written by IO redirections:</p>

<pre><code>ls -al ~ &gt; /tmp/list.tmp
grep '\.sh' &lt; /tmp/list.tmp
rm /tmp/list.tmp
</code></pre>

<p>But unix comes with a better method named pipeline which sends the standard output of one program to the standard input of another program. With pipeline the above example could be rewritten as <code>ls -al | grep '\.sh'</code>.</p>

<p>With pipeline, it is possible to compose one giant pipeline to connect pieces of programs together to perform complex operations like <code>makewords sentence | lowercase | sort | unique | mismatch </code> in <a href="http://www.youtube.com/watch?v=tc4ROCJYbm0">this example(7:00)</a>.</p>

<p>Another benefit of pipeline is that all the pieces of programs start execution as soon as data stream comes in. In the first example where a temporary file is created as a medium, <code>grep</code> is not executed until <code>ls -al</code> finishes and writes to the <code>/tmp/list.tmp</code>. In this case, if the temporary data is significantly big, <code>grep</code> needs to wait quitea while. However with pipeline, <code>grep</code> is executed once <code>ls -al</code> starts to send data through standard output. </p>

<p>Pipeline takes less space of disk and memory but with faster processing as all the program runs in parellel to process the data stream.</p>

<h2 id="pipe-standard-input--output-as-arguments">Pipe Standard Input / Output as arguments</h2>
<p>### Difference between standard streams and arguments
Sometimes the program returns the same result when read from standard input or execute with an arguments.</p>

<p><code>cat log</code> has the same result as <code>cat &lt; log</code>. But the mechanism is different.
<code>cat file</code> pass the file name <code>log</code> as an argument to <code>cat</code> but <code>cat &lt; log</code> passes the content of the <code>log</code> file as standard input to <code>cat</code>.</p>

<h3 id="process-substitution">Process substitution</h3>

<pre><code>diff &lt;(sort file1) &lt;(sort file2)
</code></pre>

<h3 id="xargs"><code>xargs</code></h3>

<pre><code>ls *.zip | xargs -n 1 -t unzip
</code></pre>

<h2 id="reference">Reference</h2>
<p><a href="http://en.wikipedia.org/wiki/Pipeline_%28Unix%29">Wikipedia Pipepine</a></p>

<p><a href="http://en.wikipedia.org/wiki/Standard_streams">Wikipedia Standard Stream</a></p>

<p><a href="http://en.wikipedia.org/wiki/Process_substitution">Wikipedia Process Substitution</a></p>

<p><a href="http://www.linfo.org/redirection.html">Redirection Definition</a></p>

<p><a href="http://tldp.org/LDP/abs/html/io-redirection.html">I/O Redirection in Advanced Bash-Scripting Guide</a></p>

<hr />

<p>All the icons used in illustration are from The Noun Project.
<a href="http://thenounproject.com/noun/hard-drive/#icon-No537">Hard Drive</a> and <a href="http://thenounproject.com/noun/computer/#icon-No115">Computer</a> is designed by annonymous designers.
<a href="http://thenounproject.com/noun/computer-keyboard/#icon-No1807">Computer Keyboard</a> is designed by <a href="http://thenounproject.com/andrewforrester">Andrew Forrester</a>.
<a href="http://thenounproject.com/noun/mouse/#icon-No890">Mouse</a> is designed by <a href="http://thenounproject.com/cbertoco">Camila Bertoco</a>.
<a href="http://thenounproject.com/noun/floppy-disk/#icon-No2476">Floppy Disk</a> is designed by <a href="http://thenounproject.com/cortiemens">Cor Tiemens</a>.</p>

<p><a href="http://thenounproject.com/noun/building-block/#icon-No5218" target="_blank">Building Block</a> designed by <a href="http://thenounproject.com/Mikhail1986" target="_blank">Michael Rowe</a> from The Noun Project
<a href="http://thenounproject.com/noun/speaker/#icon-No4106" target="_blank">Speaker</a> designed by <a href="http://thenounproject.com/squintongreen" target="_blank">Samuel Q. Green</a> from The Noun Project
<a href="http://thenounproject.com/noun/database/#icon-No4995" target="_blank">Database</a> designed by <a href="http://thenounproject.com/DmitryBaranovskiy" target="_blank">Dmitry Baranovskiy</a> from The Noun Project
<a href="http://thenounproject.com/noun/document/#icon-No4769" target="_blank">Document</a> designed by <a href="http://thenounproject.com/mariavaragilal" target="_blank">Maria Varagilal</a> from The Noun Project
<a href="http://thenounproject.com/noun/printer/#icon-No109" target="_blank">Printer</a>  from The Noun Project
<a href="http://thenounproject.com/noun/printer/#icon-No1235" target="_blank">Printer</a> designed by <a href="http://thenounproject.com/johncaserta" target="_blank">John Caserta</a> from The Noun Project
<a href="http://thenounproject.com/noun/printer/#icon-No3751" target="_blank">Printer</a> designed by <a href="http://thenounproject.com/bitsnbobs" target="_blank">James Fenton</a> from The Noun Project
<a href="http://thenounproject.com/noun/gears/#icon-No1870" target="_blank">Gears</a> designed by <a href="http://thenounproject.com/daria" target="_blank">Dasha Shevyrenkova</a> from The Noun Project
<a href="http://thenounproject.com/noun/arrow/#icon-No2487" target="_blank">Arrow</a> designed by <a href="http://thenounproject.com/cortiemens" target="_blank">Cor Tiemens</a> from The Noun Project</p>
]]></content>
  </entry>
  
</feed>
